#!/usr/bin/python2
# -*- python -*-

# Part of mlat-client - an ADS-B multilateration client.
# Copyright 2015, Oliver Jowett <oliver@mutability.co.uk>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

CLIENT_VERSION = "0.1.11"

import sys

if __name__ == '__main__':
    print >>sys.stderr, 'Hang on while I load everything (takes a few seconds on a Pi)..'

import socket, json, time, traceback, asyncore, zlib, argparse, struct, math, errno

import _modes

def log(msg, *args, **kwargs):
    print >>sys.stderr, time.ctime(), msg.format(*args,**kwargs)

def log_exc(msg, *args, **kwargs):
    print >>sys.stderr, time.ctime(), msg.format(*args,**kwargs)
    traceback.print_exc(sys.stderr)

# radians to degrees
RTOD = 180.0 / math.pi

# WGS84 ellipsoid Earth parameters
WGS84_A = 6378137.0
WGS84_F = 1.0/298.257223563
WGS84_B = WGS84_A * (1 - WGS84_F)
WGS84_ECC_SQ = 1 - WGS84_B * WGS84_B / (WGS84_A * WGS84_A)
WGS84_ECC = math.sqrt(WGS84_ECC_SQ)

# Some derived values
_wgs84_ep = math.sqrt((WGS84_A**2 - WGS84_B**2) / WGS84_B**2)
_wgs84_ep2_b = _wgs84_ep**2 * WGS84_B
_wgs84_e2_a = WGS84_ECC_SQ * WGS84_A

def ecef2llh(ecef):
    "Converts from ECEF to WGS84 lat/lon/height"

    x, y, z = ecef

    lon = math.atan2(y, x)

    p = math.sqrt(x**2 + y**2)
    th = math.atan2(WGS84_A * z, WGS84_B * p)
    lat = math.atan2(z + _wgs84_ep2_b * math.sin(th)**3,
                     p - _wgs84_e2_a * math.cos(th)**3)

    N = WGS84_A / math.sqrt(1 - WGS84_ECC_SQ * math.sin(lat)**2)
    alt = p / math.cos(lat) - N

    return (lat*RTOD, lon*RTOD, alt)

class LoggingMixin:
    def log(self, message):
        log('{0}', message)

    def log_info(self, message, type='info'):
        log('{0}: {1}', message, type)

class Stats:
    def __init__(self, now):
        self.start = now
        self.server_tx_bytes = 0
        self.server_rx_bytes = 0
        self.server_udp_bytes = 0
        self.receiver_rx_bytes = 0
        self.receiver_rx_messages = 0
        self.mlat_positions = 0

global_stats = Stats(time.time())

class SBSListener(LoggingMixin, asyncore.dispatcher):
    def __init__(self, port, connection_factory):
        asyncore.dispatcher.__init__(self)
        self.port = port

        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.set_reuse_addr()
        self.bind( ('', port) )
        self.listen(0)

        self.output_channels = set()
        self.connection_factory = connection_factory

        log('Listening for {0} on port {1}', connection_factory.describe(), port)

    def handle_accept(self):
        accepted = self.accept()
        if not accepted: return

        new_socket, address = accepted
        log('Accepted {0} from {1}:{2}', self.connection_factory.describe(), address[0], address[1])

        self.output_channels.add(self.connection_factory(self, new_socket, address))

    def send_position(self, timestamp, addr, lat, lon, alt, callsign, squawk, error_est, nstations):
        for channel in list(self.output_channels):
            channel.send_position(timestamp, addr, lat, lon, alt, callsign, squawk, error_est, nstations)

    def heartbeat(self, now):
        for channel in list(self.output_channels):
            channel.heartbeat(now)

    def disconnect(self):
        for channel in list(self.output_channels):
            channel.close()
        self.close()

def csv_quote(s):
    if s.find('\n') == -1 and s.find('"') == -1 and s.find(',') == -1: return s
    return '"' + s.replace('"', '""') + '"'

class SBSConnection(LoggingMixin, asyncore.dispatcher_with_send):
    heartbeat_interval = 30.0
    template = 'MSG,3,1,1,{addr:06X},1,{rcv_date},{rcv_time},{now_date},{now_time},{callsign},{altitude},{speed},{heading},{lat},{lon},{vrate},{squawk},{fs},{emerg},{ident},{aog}'

    def __init__(self, listener, socket, addr):
        asyncore.dispatcher_with_send.__init__(self, sock=socket)
        self.listener = listener
        self.addr = addr
        self.next_heartbeat = time.time() + self.heartbeat_interval

    @staticmethod
    def describe():
        return 'SBS connection'

    def heartbeat(self, now):
        if now > self.next_heartbeat:
            self.next_heartbeat = now + self.heartbeat_interval
            try:
                self.send('\n')
            except socket.error:
                self.handle_error()

    def close(self):
        asyncore.dispatcher_with_send.close(self)
        self.listener.output_channels.discard(self)

    def handle_read(self):
        self.recv(1024)  # discarded

    def handle_close(self):
        log('Lost SBS output connection from {0}:{1}', self.addr[0], self.addr[1])
        self.close()

    def send_position(self, timestamp, addr, lat, lon, alt, callsign, squawk, error_est, nstations):
        now = time.time()

        now_date = time.strftime("%Y/%m/%d", time.gmtime(now))
        now_time = time.strftime("%H:%M:%S", time.gmtime(now)) + ".{0:03.0f}".format(math.modf(now)[0] * 1000)
        rcv_date = time.strftime("%Y/%m/%d", time.gmtime(timestamp))
        rcv_time = time.strftime("%H:%M:%S", time.gmtime(timestamp)) + ".{0:03.0f}".format(math.modf(timestamp)[0] * 1000)
        line = self.template.format(addr=addr,
                                    rcv_date = rcv_date,
                                    rcv_time = rcv_time,
                                    now_date = now_date,
                                    now_time = now_time,
                                    callsign = csv_quote(callsign) if callsign else '',
                                    altitude = int(alt),
                                    speed = '',
                                    heading = '',
                                    lat = round(lat,4),
                                    lon = round(lon,4),
                                    vrate = '',
                                    squawk = csv_quote(squawk) if squawk else '',
                                    fs = '',
                                    emerg = '',
                                    ident = '',
                                    aog = '',
                                    error_est = error_est,
                                    nstations = nstations)

        try:
            self.send(line + '\n')
        except socket.error:
            self.handle_error()

        self.next_heartbeat = time.time() + self.heartbeat_interval

class SBSExtendedConnection(SBSConnection):
    template = 'MLAT,3,1,1,{addr:06X},1,{rcv_date},{rcv_time},{now_date},{now_time},{callsign},{altitude},{speed},{heading},{lat},{lon},{vrate},{squawk},{fs},{emerg},{ident},{aog},{nstations},,{error_est:.0f}'

    @staticmethod
    def describe():
        return 'extended-format SBS connection'

class ReconnectingConnection(LoggingMixin, asyncore.dispatcher):
    reconnect_interval = 30.0

    def __init__(self, host, port):
        asyncore.dispatcher.__init__(self)
        self.host = host
        self.port = port
        self.state = 'disconnected'
        self.reconnect_at = None

    def heartbeat(self, now):
        if self.reconnect_at is None or self.reconnect_at > now: return
        if self.state == 'ready': return
        self.reconnect_at = None
        self.reconnect()

    def close(self, manual_close=False):
        asyncore.dispatcher.close(self)

        if self.state != 'disconnected':
            if not manual_close:
                log('Lost connection to {host}:{port}', host=self.host, port=self.port)

            self.state = 'disconnected'
            self.reset_connection()
            self.lost_connection()

        if not manual_close: self.schedule_reconnect()

    def disconnect(self, reason):
        if self.state != 'disconnected':
            log('Disconnecting from {host}:{port}: {reason}', host=self.host, port=self.port, reason=reason)
            self.close(True)

    def writable(self):
        return self.connecting

    def schedule_reconnect(self):
        if self.reconnect_at is None:
            log('Reconnecting in {0} seconds', self.reconnect_interval)
            self.reconnect_at = time.time() + self.reconnect_interval

    def reconnect(self):
        if self.state != 'disconnected':
            self.disconnect('About to reconnect')

        try:
            self.reset_connection()
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.connect((self.host, self.port))
        except socket.error as e:
            log('Connection to {host}:{port} failed: {ex!s}', host=self.host, port=self.port, ex=e)
            self.close()

    def handle_connect(self):
        self.state = 'connected'
        self.start_connection()

    def handle_read(self):
        pass

    def handle_write(self):
        pass

    def handle_close(self):
        self.close()

    def handle_error(self):
        t,v,tb = sys.exc_info()
        if isinstance(v,IOError):
            log('Connection to {host}:{port} lost: {ex!s}', host=self.host, port=self.port, ex=v)
        else:
            log_exc('Unexpected exception on connection to {host}:{port}', host=self.host, port=self.port)

        self.handle_close()

    def reset_connection(self):
        pass

    def start_connection(self):
        pass

    def lost_connection(self):
        pass

class ReceiverConnection(ReconnectingConnection):
    inactivity_timeout = 150.0

    def __init__(self, host, port, connection_type):
        ReconnectingConnection.__init__(self, host, port)
        self.coordinator = None
        self.last_data_received = None
        if connection_type == 'radarcape':
            self.packetize = _modes.packetize_radarcape_input
        elif connection_type == 'beast':
            self.packetize = _modes.packetize_beast_input
        elif connection_type == 'sbs':
            self.packetize = self.find_sbs_stream_start
            self.sbs_last = 0
            self.sbs_upper_timestamp = 0
            self.sbs_reference_timestamp = None
            self.sbs_reference_systime = None
        else:
            raise NotImplementedError("no support for conn_type=" + conn_type)

    def find_sbs_stream_start(self, data):
        # initially, we might be out of sync with the stream (the Basestation seems
        # to drop us in the middle of a packet on connecting sometimes)
        # so throw away data until we see DLE STX

        # look for DLE STX
        i = data.find('\x10\x02')
        if i == 0:
            # DLE STX at the very start of input, great!
            self.packetize = self.packetize_sbs_input
            return self.packetize(data)

        while i > 0:
            # DLE STX not at the very start
            # check that it's preceeded by a non-DLE
            if data[i-1] != '\x10':
                # Success.
                self.packetize = self.packetize_sbs_input
                consumed, messages = self.packetize(data[i:])
                return (consumed + i, messages)

            # DLE DLE STX. Can't assume this is the start of a
            # packet (the STX could be data following an escaped DLE),
            # skip it.

            i = data.find('\x10\x02', i+2)

        # no luck this time
        if len(data) > 512:
            raise ValueError("Doesn't look like a Basestation input stream - no DLE STX in the first 512 bytes")

        return (0, ())

    def packetize_sbs_input(self, data):
        # SBS timestamp rolls over frequently: every 2**24 * 50ns = 838,860,800ns (~0.8s)
        # Stretch that by three more bytes using the system clock.

        consumed, messages = _modes.packetize_sbs_input(data)
        if not messages:
            return consumed, messages

        now = time.time()
        last = self.sbs_last

        for m in messages:
            t = m.timestamp + self.sbs_upper_timestamp
            if t < last:
                # rolled over
                self.sbs_upper_timestamp += (1 << 24)
                t += (1 << 24)

            m.timestamp = last = t

        if self.sbs_reference_systime is None:
            self.sbs_reference_systime = now
            self.sbs_reference_timestamp = last
        else:
            systime_delta = now - self.sbs_reference_systime
            timestamp_delta = (last - self.sbs_reference_timestamp) * 50e-9

            if abs(timestamp_delta - systime_delta) > 0.838860800*10:
                log("SBS timestamp drift: timestamps elapsed {t:.9f}s, system elapsed {s:.9f}s, drift {d:.9f}s",
                    t=timestamp_delta,
                    s=systime_delta,
                    d=systime_delta - timestamp_delta)
                self.sbs_reference_systime = now
                self.sbs_reference_timestamp = last

        self.sbs_last = last
        return consumed, messages

    def reset_connection(self):
        self.readbuf = bytearray()

    def start_connection(self):
        log('Input connected to {0}:{1}', self.host, self.port)
        self.last_data_received = time.time()
        self.state = 'ready'
        self.coordinator.input_connected()

    def lost_connection(self):
        self.coordinator.input_disconnected()

    def heartbeat(self, now):
        ReconnectingConnection.heartbeat(self,now)

        if self.state == 'ready' and (now - self.last_data_received) > self.inactivity_timeout:
            self.disconnect('No data (not even keepalives) received for {0:.0f} seconds'.format(self.inactivity_timeout))
            self.reconnect()

    def handle_read(self):
        try:
            moredata = bytearray(self.recv(16384))
        except socket.error as e:
            if e.errno == errno.EAGAIN:
                return
            raise

        if not moredata:
            self.close()
            return

        self.last_data_received = time.time()
        self.readbuf += moredata
        global_stats.receiver_rx_bytes += len(moredata)
            
        consumed,messages = self.packetize(self.readbuf)
        if consumed: self.readbuf = self.readbuf[consumed:]        
        if len(self.readbuf) > 5120:
            raise RuntimeError('parser broken - buffer not being consumed')

        if messages:
            global_stats.receiver_rx_messages += len(messages)
            self.coordinator.input_received_messages(messages)

class ServerConnection(ReconnectingConnection):
    reconnect_interval = 30.0
    heartbeat_interval = 120.0

    TYPE_SYNC = 1
    TYPE_MLAT_SHORT = 2
    TYPE_MLAT_LONG = 3
    TYPE_SSYNC = 4
    TYPE_REBASE = 5
    TYPE_ABS_SYNC = 6

    STRUCT_HEADER = struct.Struct(">IHQ")
    STRUCT_SYNC = struct.Struct(">Bii14s14s")
    STRUCT_SSYNC = struct.Struct(">Bi14s")
    STRUCT_MLAT_SHORT = struct.Struct(">Bi7s")
    STRUCT_MLAT_LONG = struct.Struct(">Bi14s")
    STRUCT_REBASE = struct.Struct(">BQ")
    STRUCT_ABS_SYNC = struct.Struct(">BQQ14s14s")

    def __init__(self, host, port, handshake_data, offer_zlib, offer_udp, return_results):
        ReconnectingConnection.__init__(self, host, port)
        self.handshake_data = handshake_data
        self.offer_zlib = offer_zlib
        self.offer_udp = offer_udp
        self.return_results = return_results
        self.coordinator = None
        self.selective_traffic = False
        self.rate_reports = False
        self.udp_sock = None

        self.reset_connection()

    def reset_connection(self):
        self.readbuf = ''
        self.writebuf = ''
        self.linebuf = []
        self.fill_writebuf = None
        self.handle_server_line = None
        self.server_heartbeat_at = None

        if self.udp_sock:
           self.udp_sock.close()

        self.udp_sock = None
        self.udp_key = None
        self.udp_time = None
        self.udp_header_time = None
        self.udp_buf = bytearray(1500)
        self.udp_next = self.STRUCT_HEADER.size
        self.udp_seq = 0

    def lost_connection(self):
        self.coordinator.server_disconnected()

    def readable(self):
        return self.handle_server_line is not None

    def writable(self):
        return self.connecting or self.writebuf or (self.fill_writebuf and self.linebuf)

    def handle_write(self):
        if self.fill_writebuf:
            self.fill_writebuf()

        if self.writebuf:
            sent = self.send(self.writebuf)
            self.writebuf = self.writebuf[sent:]
            global_stats.server_tx_bytes += sent
            if len(self.writebuf) > 65536:
                raise IOError('Server write buffer overflow (too much unsent data)')

    def fill_uncompressed(self):
        if not self.linebuf: return
        for line in self.linebuf:
            self.writebuf += line + '\n'
        self.linebuf = []

    def fill_zlib(self):
        if not self.linebuf: return

        data = ''
        pending = False
        for line in self.linebuf:
            data += self.compressor.compress(line + '\n')
            pending = True

            if len(data) >= 32768:
                data += self.compressor.flush(zlib.Z_SYNC_FLUSH)
                assert len(data) < 65536
                assert data[-4:] == '\x00\x00\xff\xff'
                data = struct.pack('!H', len(data)-4) + data[:-4]
                self.writebuf += data
                data = ''
                pending = False

        if pending:
            data += self.compressor.flush(zlib.Z_SYNC_FLUSH)
            assert len(data) < 65536
            assert data[-4:] == '\x00\x00\xff\xff'
            data = struct.pack('!H', len(data)-4) + data[:-4]
            self.writebuf += data    

        self.linebuf = []

    def send_json(self, o):
        #log('Send: {0}', o)
        self.linebuf.append(json.dumps(o, separators=(',',':')))

    #
    # TCP transport
    #

    def send_tcp_mlat(self, message):
        self.linebuf.append('{{"mlat":{{"t":{0},"m":"{1}"}}}}'.format(message.timestamp, str(message)))

    def send_tcp_mlat_and_alt(self, message, altitude):
        self.linebuf.append('{{"mlat":{{"t":{0},"m":"{1}","a":{2}}}}}'.format(message.timestamp, str(message), altitude))

    def send_tcp_sync(self, em, om):
        self.linebuf.append('{{"sync":{{"et":{0},"em":"{1}","ot":{2},"om":"{3}"}}}}'.format(em.timestamp, str(em), om.timestamp, str(om)))

    def send_tcp_split_sync(self, m):
        self.linebuf.append('{{"ssync":{{"t":{0},"m":"{1}"}}}}'.format(m.timestamp, str(m)))

    #
    # UDP transport
    #

    def send_udp_mlat(self, message, altitude=None):
        # nb: altitude is ignored!

        if self.udp_time is None:
            self.udp_time = self.udp_header_time = message.timestamp
            delta = 0
        else:
            delta = message.timestamp - self.udp_time
            if abs(delta) > 0x7FFFFFF0:
                self.udp_time = message.timestamp
                delta = 0
                self.STRUCT_REBASE.pack_into(self.udp_buf, self.udp_next, self.TYPE_REBASE, self.udp_time)
                self.udp_next += self.STRUCT_REBASE.size

        if len(message) == 7:
            self.STRUCT_MLAT_SHORT.pack_into(self.udp_buf, self.udp_next, self.TYPE_MLAT_SHORT, delta, str(buffer(message)))
            self.udp_next += self.STRUCT_MLAT_SHORT.size

        else:
            self.STRUCT_MLAT_LONG.pack_into(self.udp_buf, self.udp_next, self.TYPE_MLAT_LONG, delta, str(buffer(message)))
            self.udp_next += self.STRUCT_MLAT_LONG.size

        if self.udp_next > 1200:
            self.flush_udp()

    def send_udp_sync(self, em, om):
        if self.udp_time is None:
            self.udp_time = self.udp_header_time = (em.timestamp + om.timestamp) / 2

        if abs(em.timestamp - om.timestamp) > 0xFFFFFFF0:
            # use abs sync
            self.STRUCT_ABS_SYNC.pack_into(self.udp_buf, self.udp_next, self.TYPE_ABS_SYNC, em.timestamp, om.timestamp, str(buffer(em)), str(buffer(om)))
            self.udp_next += self.STRUCT_ABS_SYNC.size
        else:
            edelta = em.timestamp - self.udp_time
            odelta = om.timestamp - self.udp_time
            if abs(edelta) > 0x7FFFFFF0 or abs(odelta) > 0x7FFFFFF0:
                self.udp_time = (em.timestamp + om.timestamp) / 2
                self.STRUCT_REBASE.pack_into(self.udp_buf, self.udp_next, self.TYPE_REBASE, self.udp_time)
                self.udp_next += self.STRUCT_REBASE.size
                edelta = em.timestamp - self.udp_time
                odelta = om.timestamp - self.udp_time

            self.STRUCT_SYNC.pack_into(self.udp_buf, self.udp_next, self.TYPE_SYNC, edelta, odelta, str(buffer(em)), str(buffer(om)))
            self.udp_next += self.STRUCT_SYNC.size

        if self.udp_next > 1200:
            self.flush_udp()

    def send_udp_split_sync(self, m):
        if self.udp_time is None:
            self.udp_time = self.udp_header_time = m.timestamp
            delta = 0
        else:
            delta = m.timestamp - self.udp_time
            if abs(delta) > 0x7FFFFFF0:
                self.udp_time = m.timestamp
                delta = 0
                self.STRUCT_REBASE.pack_into(self.udp_buf, self.udp_next, self.TYPE_REBASE, self.udp_time)
                self.udp_next += self.STRUCT_REBASE.size

        self.STRUCT_SSYNC.pack_into(self.udp_buf, self.udp_next, self.TYPE_SSYNC, delta, str(buffer(m)))
        self.udp_next += self.STRUCT_SSYNC.size

        if self.udp_next > 1200:
            self.flush_udp()

    def flush_udp(self):
        self.STRUCT_HEADER.pack_into(self.udp_buf, 0, self.udp_key, self.udp_seq, self.udp_header_time)
        try:
            self.udp_sock.send(buffer(self.udp_buf, 0, self.udp_next))
        except socket.error:
            pass
        global_stats.server_udp_bytes += self.udp_next
        self.udp_next = self.STRUCT_HEADER.size
        self.udp_time = None
        self.udp_seq = (self.udp_seq + 1) & 0xffff

    def send_seen(self, aclist):
        self.send_json({'seen': ['{0:06x}'.format(icao) for icao in aclist]})

    def send_lost(self, aclist):
        self.send_json({'lost': ['{0:06x}'.format(icao) for icao in aclist]})

    def send_rate_report(self, report):
        if self.rate_reports:
            r2 = dict([('{0:06X}'.format(k), round(v, 2)) for k,v in report.items()])
            self.send_json({'rate_report': r2})

    def start_connection(self):
        log('Connected to multilateration server at {0}:{1}, handshaking', self.host, self.port)
        self.state = 'handshaking'

        compress_methods = ['none']
        if self.offer_zlib:
            compress_methods.append('zlib')
            compress_methods.append('zlib2')

        handshake_msg = { 'version': 2,
                          'client_version': CLIENT_VERSION,
                          'compress': compress_methods,
                          'selective_traffic': True,
                          'heartbeat': True,
                          'return_results': self.return_results,
                          'udp_transport': 2 if self.offer_udp else False,
                          'return_result_format': 'ecef' }
        handshake_msg.update(self.handshake_data)
        self.writebuf += json.dumps(handshake_msg) + '\n' # linebuf not used yet
        self.consume_readbuf = self.consume_readbuf_uncompressed
        self.handle_server_line = self.handle_handshake_response

    def heartbeat(self, now):
        ReconnectingConnection.heartbeat(self,now)

        if self.udp_time is not None:
            self.flush_udp()

        if self.server_heartbeat_at is not None and self.server_heartbeat_at < now:
            self.server_heartbeat_at = now + self.heartbeat_interval
            self.send_json({'heartbeat': {'client_time': round(now, 3)}})

    def handle_read(self):
        try:
            moredata = self.recv(16384)
        except socket.error as e:
            if e.errno == errno.EAGAIN:
                return
            raise

        if not moredata:
            self.close()
            self.schedule_reconnect()
            return

        self.readbuf += moredata
        global_stats.server_rx_bytes += len(moredata)
        self.consume_readbuf()

    def consume_readbuf_uncompressed(self):
        lines = self.readbuf.split('\n')
        self.readbuf = lines[-1]
        for line in lines[:-1]:
            try:
                msg = json.loads(line)
            except ValueError:
                log("json parsing problem, line: >>{line}<<", line=line)
                raise

            self.handle_server_line(msg)

    def consume_readbuf_zlib(self):
        i = 0
        while i + 2 < len(self.readbuf):
            hlen, = struct.unpack_from('!H', self.readbuf, i)
            end = i + 2 + hlen
            if end > len(self.readbuf):
                break

            packet = self.readbuf[i + 2:end] + '\x00\x00\xff\xff'
            linebuf = self.decompressor.decompress(packet)
            lines = linebuf.split('\n')
            for line in lines[:-1]:
                try:
                    msg = json.loads(line)
                except ValueError:
                    log("json parsing problem, line: >>{line}<<", line=line)
                    raise

                self.handle_server_line(msg)

            i = end

        self.readbuf = self.readbuf[i:]

    def handle_handshake_response(self, response):
        if 'reconnect_in' in response:
            self.reconnect_interval = response['reconnect_in']

        if 'deny' in response:
            log('Server explicitly rejected our connection, saying:')
            for reason in response['deny']:
                log('  {0}', reason)
            raise IOError('Server rejected our connection attempt')

        if 'motd' in response:
            log('Server says: {0}', response['motd'])

        compress = response.get('compress', 'none')
        if response['compress'] == 'none':
            self.fill_writebuf = self.fill_uncompressed
            self.consume_readbuf = self.consume_readbuf_uncompressed
        elif response['compress'] == 'zlib' and self.offer_zlib:
            self.compressor = zlib.compressobj(1)
            self.fill_writebuf = self.fill_zlib
            self.consume_readbuf = self.consume_readbuf_uncompressed
        elif response['compress'] == 'zlib2' and self.offer_zlib:
            self.compressor = zlib.compressobj(1)
            self.decompressor = zlib.decompressobj()
            self.fill_writebuf = self.fill_zlib
            self.consume_readbuf = self.consume_readbuf_zlib
        else:
            raise IOError('Server response asked for a compression method {0}, which we do not support'.format(response['compress']))

        self.selective_traffic = response.get('selective_traffic', False)
        if response.get('heartbeat',False):
            self.server_heartbeat_at = time.time() + self.heartbeat_interval

        if 'udp_transport' in response:
            host, port, key = response['udp_transport']
            if not host:
                host = self.host

            self.udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            log("UDP: sending to {0} {1}", host, port)
            self.udp_sock.connect((host, port))
            self.udp_key = key
            self.send_mlat = self.send_udp_mlat
            self.send_mlat_and_alt = self.send_udp_mlat
            self.send_sync = self.send_udp_sync
            self.send_split_sync = self.send_udp_split_sync
        else:
            self.udp_sock = None
            self.udp_key = None
            self.send_mlat = self.send_tcp_mlat
            self.send_mlat_and_alt = self.send_tcp_mlat_and_alt
            self.send_sync = self.send_tcp_sync
            self.send_split_sync = self.send_tcp_split_sync

        self.rate_reports = response.get('rate_reports', False)
        self.split_sync = response.get('split_sync', False)

        log('Handshake complete.')
        log('  Compression:       {0}', compress)
        log('  Selective traffic: {0}', self.selective_traffic and 'enabled' or 'disabled')
        log('  Heartbeats:        {0}', self.server_heartbeat_at and 'enabled' or 'disabled')
        log('  UDP transport:     {0}', self.udp_sock and 'enabled' or 'disabled')
        log('  Rate reports:      {0}', self.rate_reports and 'enabled' or 'disabled')
        log('  Split sync:        {0}', self.split_sync and 'enabled' or 'disabled')
        #log('  Return traffic:    {0}', response.get('return_traffic',False) and 'enabled' or 'disabled')

        self.state = 'ready'
        self.handle_server_line = self.handle_connected_request
        self.coordinator.server_connected()

        # dummy rate report to indicate we'll be sending them
        if self.rate_reports:
            self.send_rate_report({})

    def handle_connected_request(self, request):
        #log('Receive: {0}', request)
        if 'start_sending' in request:
            self.coordinator.start_sending([int(x,16) for x in request['start_sending']])
        elif 'stop_sending' in request:
            self.coordinator.stop_sending([int(x,16) for x in request['stop_sending']])
        elif 'heartbeat' in request:
            pass
        elif 'result' in request:
            result = request['result']
            ecef = result.get('ecef')
            if ecef is not None:
                # new format
                lat, lon, alt = ecef2llh(ecef)
                alt = alt / 0.3038   # convert meters to feet
                ecef_cov = result.get('cov')
                if ecef_cov:
                    var_est = ecef_cov[0] + ecef_cov[3] + ecef_cov[5]
                    if var_est >= 0:
                        error_est = math.sqrt(var_est)
                    else:
                        error_est = -1
                else:
                    error_est = -1
                nstations = result['nd']
                callsign = None
                squawk = None
            else:
                lat = result['lat']
                lon = result['lon']
                alt = result['alt']
                error_est = result['gdop'] * 300   # make a guess
                nstations = result['nstations']
                callsign = result['callsign']
                squawk = result['squawk']

            self.coordinator.received_mlat_result(timestamp=result['@'],
                                                  addr=int(result['addr'],16),
                                                  lat=lat,
                                                  lon=lon,
                                                  alt=alt,
                                                  callsign=callsign,
                                                  squawk=squawk,
                                                  error_est=error_est,
                                                  nstations=nstations)
        else:
            log('ignoring request from server: {0}', request)

class Aircraft:
    def __init__(self, icao):
        self.icao = icao
        self.messages = 0
        self.last_message_timestamp = 0
        self.last_position_timestamp = 0
        self.last_altitude_timestamp = 0
        self.altitude = None
        self.even_message = None
        self.odd_message = None
        self.reported = False
        self.requested = True
        self.measurement_start = None
        self.rate_measurement_start = 0
        self.recent_adsb_positions = 0

class Coordinator:
    report_interval = 30.0
    stats_interval = 900.0

    def __init__(self, receiver, server, outputs, freq, radarcape_gps):
        self.receiver = receiver
        self.server = server
        self.outputs = outputs
        self.freq = freq
        self.radarcape_gps = radarcape_gps

        self.aircraft = {}
        self.requested_traffic = set()
        self.df_handlers = {
            0: self.received_df_misc_alt,
            4: self.received_df_misc_alt,
            5: self.received_df_misc_noalt,
            16: self.received_df_misc_alt,
            20: self.received_df_misc_alt,
            21: self.received_df_misc_noalt,
            11: self.received_df11,
            17: self.received_df17
        }
        self.last_rcv_timestamp = None

        self.next_report = None
        self.next_stats = time.time() + self.stats_interval

        receiver.coordinator = self
        server.coordinator = self

    def run(self):
        try:
            self.server.reconnect()

            next_heartbeat = time.time() + 0.5
            while True:
                # maybe there are no active sockets and
                # we're just waiting on a timeout
                if asyncore.socket_map:
                    asyncore.loop(timeout=0.2, count=5)
                else:
                    time.sleep(1.0)

                now = time.time()
                if now >= next_heartbeat:
                    next_heartbeat = now + 0.5
                    self.heartbeat(now)

        finally:
            if self.receiver.socket: self.receiver.disconnect('Client shutting down')
            if self.server.socket: self.server.disconnect('Client shutting down')
            for o in self.outputs: o.disconnect()

    def input_connected(self):
        self.last_rcv_timestamp = 0
        self.server.send_json({'input_connected' : 'OK'})

    def input_disconnected(self):
        self.server.send_json({'input_disconnected' : 'no longer connected'})
        # expire everything
        discarded = list(self.aircraft.keys())
        self.aircraft.clear()
        self.server.send_lost(discarded)

    def server_connected(self):
        self.requested_traffic = set()
        self.newly_seen = set()
        self.aircraft = {}
        self.next_report = time.time() + self.report_interval
        if self.receiver.state != 'ready':
            self.receiver.reconnect()

    def server_disconnected(self):
        self.receiver.disconnect('Lost connection to multilateration server, no need for input data')
        self.next_report = None
        self.next_rate_report = None
        self.next_expiry = None

    def input_received_messages(self, messages):
        for message in messages:
            if message.timestamp == 0:
                # heartbeat etc
                continue

            if message.timestamp < self.last_rcv_timestamp:
                if self.radarcape_gps and (message.timestamp < 60e9) and (self.last_rcv_timestamp > 86340e9):
                    # probably end of day rollover
                    log("Radarcape end-of-day GPS timestamp rollover")
                    # force a server clock reset:
                    self.server.send_json({'clock_reset' : 'GPS rollover'})

                elif (self.last_rcv_timestamp - message.timestamp) > self.freq * 90:
                    log("Very out of range message timestamp seen (last {0:012x}, now {1:012x}). Assuming something is horribly wrong and forcing a reconnect.", self.last_rcv_timestamp, message.timestamp)
                    self.receiver.disconnect('Timestamp problems')
                    self.receiver.schedule_reconnect()
                    return

                else:
                    continue

            self.last_rcv_timestamp = message.timestamp

            if not message.valid:
                continue

            handler = self.df_handlers.get(message.df)
            if handler: handler(message)

    def start_sending(self, icao_list):
        for icao in icao_list:
            ac = self.aircraft.get(icao)
            if ac: ac.requested = True
        self.requested_traffic.update(icao_list)

    def stop_sending(self, icao_list):
        for icao in icao_list:
            ac = self.aircraft.get(icao)
            if ac: ac.requested = False
        self.requested_traffic.difference_update(icao_list)

    def heartbeat(self, now):
        self.receiver.heartbeat(now)
        self.server.heartbeat(now)
        for o in self.outputs:
            o.heartbeat(now)

        if self.next_report and now >= self.next_report:
            self.next_report = now + self.report_interval
            self.send_aircraft_report()
            self.expire()
            self.send_rate_report()

        if now >= self.next_stats:
            self.next_stats = now + self.stats_interval
            self.periodic_stats(now)

    def report_aircraft(self, ac):
        ac.reported = True
        if not self.server.selective_traffic:
            ac.requested = True
        self.newly_seen.add(ac.icao)

    def send_aircraft_report(self):
        if self.newly_seen:
            #log('Telling server about {0} new aircraft', len(self.newly_seen))
            self.server.send_seen(self.newly_seen)
            self.newly_seen.clear()

    def send_rate_report(self):
        # report ADS-B position rate stats
        rate_report = {}
        for ac in self.aircraft.values():
            interval = (self.last_rcv_timestamp - ac.rate_measurement_start) / float(self.freq)
            if interval > 0 and self.last_rcv_timestamp - ac.last_position_timestamp < 60 * self.freq:
                rate = 1.0 * ac.recent_adsb_positions / interval
                ac.rate_measurement_start = self.last_rcv_timestamp
                ac.recent_adsb_positions = 0
                rate_report[ac.icao] = rate

        if rate_report:
            self.server.send_rate_report(rate_report)
            
    def expire(self):
        discarded = []
        for ac in self.aircraft.values():
            if (self.last_rcv_timestamp - ac.last_message_timestamp) > 60 * self.freq:
                if ac.reported:
                    discarded.append(ac.icao)
                del self.aircraft[ac.icao]

        if discarded:
            self.server.send_lost(discarded)

    def periodic_stats(self, now):
        global global_stats

        elapsed = now - global_stats.start
        log('Receiver: {0}; {1:6.1f} msg/s received     {2:4.1f}kB/s from receiver',
            self.receiver.state,
            global_stats.receiver_rx_messages / elapsed,
            global_stats.receiver_rx_bytes / elapsed / 1000.0)
        log('Server:   {0}; {1:6.1f} kB/s from server   {2:4.1f}kB/s TCP to server  {3:4.1f}kB/s UDP to server',
            self.server.state,
            global_stats.server_rx_bytes / elapsed / 1000.0,
            global_stats.server_tx_bytes / elapsed / 1000.0,
            global_stats.server_udp_bytes / elapsed / 1000.0)
        log('Aircraft: {0} known, {1} requested by server',
            len(self.aircraft), len(self.requested_traffic))
        if self.server.return_results:
            log('Results:  {0:3.1f} positions/minute',
                global_stats.mlat_positions / elapsed * 60.0)
        global_stats = Stats(now)

    def received_df_misc_noalt(self, message):
        ac = self.aircraft.get(message.address)
        if not ac: return False  # not a known ICAO

        ac.messages += 1
        ac.last_message_timestamp = message.timestamp

        if ac.messages < 10: return   # wait for more messages
        if not ac.reported:
            self.report_aircraft(ac)
            return
        if not ac.requested:
            return

        # Candidate for MLAT
        if message.timestamp - ac.last_position_timestamp < 60 * self.freq: return   # reported position recently, no need for mlat
        if message.timestamp - ac.last_altitude_timestamp > 15 * self.freq: return   # too long since altitude reported
        self.server.send_mlat_and_alt(message, ac.altitude)

    def received_df_misc_alt(self, message):
        if not message.altitude: return

        ac = self.aircraft.get(message.address)
        if not ac: return False  # not a known ICAO

        ac.messages += 1
        ac.last_message_timestamp = message.timestamp
        ac.last_altitude_timestamp = message.timestamp
        ac.altitude = message.altitude

        if ac.messages < 10: return   # wait for more messages
        if not ac.reported:
            self.report_aircraft(ac)
            return
        if not ac.requested:
            return

        # Candidate for MLAT
        if message.timestamp - ac.last_position_timestamp < 60 * self.freq: return   # reported position recently, no need for mlat
        self.server.send_mlat(message)

    def received_df11(self, message):
        ac = self.aircraft.get(message.address)
        if not ac:
            ac = Aircraft(message.address)
            ac.requested = (message.address in self.requested_traffic)
            ac.messages += 1
            ac.last_message_timestamp = message.timestamp
            ac.rate_measurement_start = message.timestamp
            self.aircraft[message.address] = ac
            return # will need some more messages..

        ac.messages += 1
        ac.last_message_timestamp = message.timestamp

        if ac.messages < 10: return   # wait for more messages
        if not ac.reported:
            self.report_aircraft(ac)
            return
        if not ac.requested:
            return

        # Candidate for MLAT
        if message.timestamp - ac.last_position_timestamp < 60 * self.freq: return   # reported position recently, no need for mlat
        if message.timestamp - ac.last_altitude_timestamp > 15 * self.freq: return   # no recent altitude available
        self.server.send_mlat_and_alt(message, ac.altitude)

    def received_df17(self, message):
        ac = self.aircraft.get(message.address)
        if not ac:
            ac = Aircraft(message.address)
            ac.requested = (message.address in self.requested_traffic)
            ac.messages += 1
            ac.last_message_timestamp = message.timestamp
            ac.rate_measurement_start = message.timestamp
            self.aircraft[message.address] = ac
            return # wait for more messages

        ac.messages += 1
        ac.last_message_timestamp = message.timestamp
        if ac.messages < 10: return
        if not ac.reported:
            self.report_aircraft(ac)
            return

        if not message.even_cpr and not message.odd_cpr:
            # not a position message
            return

        ac.last_position_timestamp = message.timestamp

        if message.altitude is None: return    # need an altitude
        if message.nuc < 6: return             # need NUCp >= 6

        ac.recent_adsb_positions += 1

        if self.server.split_sync:
            if not ac.requested:
                return

            # this is a useful reference message
            self.server.send_split_sync(message)
        else:
            if message.even_cpr:
                ac.even_message = message
            else:
                ac.odd_message = message

            if not ac.requested:
                return
            if not ac.even_message or not ac.odd_message:
                return
            if abs(ac.even_message.timestamp - ac.odd_message.timestamp) > 5 * self.freq:
                return

            # this is a useful reference message pair
            self.server.send_sync(ac.even_message, ac.odd_message)

    def received_mlat_result(self, timestamp, addr, lat, lon, alt, callsign, squawk, error_est, nstations):
        global_stats.mlat_positions += 1
        for o in self.outputs:
            o.send_position(timestamp, addr, lat, lon, alt, callsign, squawk, error_est, nstations)

def main():
    def latitude(s):
        lat = float(s)
        if lat < -90 or lat > 90:
            raise argparse.ArgumentTypeError('Latitude %s must be in the range -90 to 90' % s)
        return lat

    def longitude(s):
        lon = float(s)
        if lon < -180 or lon > 360:
            raise argparse.ArgumentTypeError('Longitude %s must be in the range -180 to 360' % s)
        if lon > 180:
            lon -= 360
        return lon

    def altitude(s):
        if s.endswith('m'):
            alt = float(s[:-1])
        elif s.endswith('ft'):
            alt = float(s[:-2]) * 0.3048
        else:
            alt = float(s)

        # Wikipedia to the rescue!
        # "The lowest point on dry land is the shore of the Dead Sea [...]
        # 418m below sea level". Perhaps not the best spot for a receiver?
        # La Rinconada, Peru, pop. 30,000, is at 5100m.
        if alt < -420 or alt > 5100:
            raise argparse.ArgumentTypeError('Altitude %s must be in the range -420m to 6000m' % s)
        return alt

    def port(s):
        port = int(s)
        if port < 1 or port > 65535:
            raise argparse.ArgumentTypeError('Port %s must be in the range 1 to 65535' % s)
        return port

    def percentage(s):
        p = int(s)
        if p < 0 or p > 100:
            raise argparse.ArgumentTypeError('Percentage %s must be in the range 0 to 100' % s)
        return p / 100.0

    receiver_types = {
        # input type -> clock frequency, server clock type, connection type

        # "dump1090" / "beast" / "radarcape_12mhz" are functionally equivalent for the client,
        # but telling the server the difference lets it apply different parameters for clock
        # error / max drift
        'dump1090': (12000000, 'dump1090', 'beast'),
        'beast': (12000000, 'beast', 'beast'),
        'radarcape_12mhz': (12000000, 'radarcape_12mhz', 'beast'),
        'radarcape_gps': (1000000000, 'radarcape_gps', 'radarcape'),
        'sbs': (20000000, 'sbs', 'sbs')
    }

    parser = argparse.ArgumentParser(description="Client for multilateration.")

    location = parser.add_argument_group('Receiver location')
    location.add_argument('--lat',
                          type=latitude,
                          help="Latitude of the receiver, in decimal degrees. Required.",
                          required=True)
    location.add_argument('--lon',
                          type=longitude,
                          help="Longitude of the receiver, in decimal degrees. Required.",
                          required=True)
    location.add_argument('--alt',
                          type=altitude,
                          help="Altitude of the receiver (AMSL).  Required. Defaults to metres, but units may specified with a 'ft' or 'm' suffix. (Except if they're negative due to option parser weirdness. Sorry!)",
                          required=True)
    location.add_argument('--privacy',
                          help="Sets the privacy flag for this receiver. Currently, this removes the receiver location pin from the coverage maps.",
                          action='store_true',
                          default=False)


    inputs = parser.add_argument_group('Mode S receiver input connection')
    inputs.add_argument('--input-type',
                        help="Sets the input receiver type.",
                        choices=receiver_types.keys(),
                        default='dump1090')
    inputs.add_argument('--clock-type',
                        dest='input_type',
                        help="Compatibility alias for --input-type.",
                        choices=receiver_types.keys())
    inputs.add_argument('--input-host',
                        help="Host (IP or hostname) to connect to for Mode S traffic.  Required.",
                        required=True)
    inputs.add_argument('--input-port',
                        help="Port to connect to for Mode S traffic. For SBS receivers, use port 30006. For Radarcape receivers, use port 10002.",
                        type=port,
                        default=30005)

    outputs = parser.add_argument_group('Multilateration server connection')
    outputs.add_argument('--user',
                         help="User information to give to the server. Used to get in touch if there are problems.",
                         required=True)
    outputs.add_argument('--output-host',
                         help="Host (IP or hostname) of the multilateration server",
                         default="mlat.mutability.co.uk")
    outputs.add_argument('--output-port',
                         help="Port of the multilateration server",
                         type=port,
                         default=40147)
    outputs.add_argument('--no-compression',
                         dest='compress',
                         help="Don't offer to use zlib compression to the multilateration server",
                         action='store_false',
                         default=True)
    outputs.add_argument('--no-udp',
                         dest='udp',
                         help="Don't offer to use UDP transport for sync/mlat messages",
                         action='store_false',
                         default=True)

    results = parser.add_argument_group('Results output')
    results.add_argument('--sbs-port',
                         help="Local port to listen on for connections that will receive Basestation 'port 30003'-format results.",
                         type=port)
    results.add_argument('--sbs-ext-port',
                         help="Local port to listen on for connections that will receive extended results in a Basestation-like format",
                         type=port)

    args = parser.parse_args()

    outputs = []
    if args.sbs_port:
        outputs.append(SBSListener(args.sbs_port,SBSConnection))
    if args.sbs_ext_port:
        outputs.append(SBSListener(args.sbs_ext_port,SBSExtendedConnection))

    freq, clock_type, conn_type = receiver_types[args.input_type]

    receiver = ReceiverConnection(host=args.input_host, port=args.input_port, connection_type=conn_type)
    server = ServerConnection(host=args.output_host, port=args.output_port,
                              handshake_data={'lat':args.lat,
                                              'lon':args.lon,
                                              'alt':args.alt,
                                              'user':args.user,
                                              'clock_type':clock_type,
                                              'privacy':args.privacy},
                              offer_zlib=args.compress,
                              offer_udp=args.udp,
                              return_results=(len(outputs) > 0))

    coordinator = Coordinator(receiver = receiver, server = server, outputs = outputs, freq=freq,
                              radarcape_gps = (clock_type == 'radarcape_gps'))
    coordinator.run()

if __name__ == '__main__':
    main()
